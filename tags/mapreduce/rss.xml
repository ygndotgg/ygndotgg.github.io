<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>YGN&#x27;s Blog - mapreduce</title>
      <link>https://ygndotgg.github.io</link>
      <description>Personal blog about programming and tech</description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://ygndotgg.github.io/tags/mapreduce/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Sat, 15 Feb 2025 00:00:00 +0000</lastBuildDate>
      <item>
          <title>MapReduce in Rust: A Hands-On Guide to Building Distributed Systems from Scratch</title>
          <pubDate>Sat, 15 Feb 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://ygndotgg.github.io/mapreduce/</link>
          <guid>https://ygndotgg.github.io/mapreduce/</guid>
          <description xml:base="https://ygndotgg.github.io/mapreduce/">&lt;h1 id=&quot;mapreduce-in-rust-a-hands-on-guide-to-building-distributed-systems-from-scratch&quot;&gt;MapReduce in Rust: A Hands-On Guide to Building Distributed Systems from Scratch&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;em&gt;&quot;You don&#x27;t truly understand distributed systems until you&#x27;ve built one from scratch.&quot;&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;That&#x27;s what everyone tells you. Building a production-grade distributed system involves countless edge cases, failure scenarios, and subtle synchronization challenges that are impossible to appreciate until you&#x27;ve debugged a race condition at 3 AM.&lt;&#x2F;p&gt;
&lt;p&gt;But honestly, they are WRONG. You don&#x27;t need production scale to understand distributed systems. You need a working implementation that forces you to confront every hard problem the field has to offer.&lt;&#x2F;p&gt;
&lt;p&gt;This is a technical deep-dive into building a MapReduce system in Rust, from first principles to a working implementation. We&#x27;ll cover RPC communication, fault tolerance, task scheduling, and the elegant simplicity that makes MapReduce such a powerful abstraction.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;what-this-post-covers&quot;&gt;What This Post Covers&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;&#x2F;mapreduce&#x2F;#part-i-the-foundation&quot;&gt;Part I: The Foundation&lt;&#x2F;a&gt;&lt;&#x2F;strong&gt; - RPC, gRPC, and the communication layer that makes distributed systems possible&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;&#x2F;mapreduce&#x2F;#part-ii-the-master&quot;&gt;Part II: The Master&lt;&#x2F;a&gt;&lt;&#x2F;strong&gt; - Task scheduling, fault tolerance through backup tasks, and health checks for stuck workers&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;&#x2F;mapreduce&#x2F;#part-iii-the-worker&quot;&gt;Part III: The Worker&lt;&#x2F;a&gt;&lt;&#x2F;strong&gt; - Map and Reduce implementation, partitioning, and atomic file operations&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;&#x2F;mapreduce&#x2F;#part-iv-the-complete-system&quot;&gt;Part IV: The Complete System&lt;&#x2F;a&gt;&lt;&#x2F;strong&gt; - Putting it all together, code architecture, and running the system&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;prologue-where-does-it-all-started&quot;&gt;Prologue: Where Does it All Started&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;the-mapreduce-abstraction&quot;&gt;The MapReduce Abstraction&lt;&#x2F;h3&gt;
&lt;p&gt;In 2004, Google published a paper that would revolutionize how we process large-scale data: &quot;MapReduce: Simplified Data Processing on Large Clusters.&quot; The idea was elegantly simple—any problem can be solved by breaking it into two phases:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Map&lt;&#x2F;strong&gt;: Transform raw input into key-value pairs&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Reduce&lt;&#x2F;strong&gt;: Aggregate those pairs into final results&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;This abstraction is powerful because it hides all the complexity of distributed computing behind two function signatures. You don&#x27;t need to think about network partitions, load balancing, or fault tolerance. The framework handles it all.&lt;&#x2F;p&gt;
&lt;p&gt;But here&#x27;s the thing—reading about it and implementing it are completely different experiences.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;my-journey-from-curiosity-to-implementation&quot;&gt;My Journey: From Curiosity to Implementation&lt;&#x2F;h3&gt;
&lt;p&gt;I first encountered MapReduce in academic course MIT 6.824 Distributed Systems, I had understood, its motive but there are some small pitholes that only filled when i try to implement it on my own.&lt;&#x2F;p&gt;
&lt;p&gt;This is the story of building a MapReduce system in Rust, Althrough it was supposed to Finish the Lab1 of MIT 6.824 Distributed Systems&lt;&#x2F;p&gt;
&lt;p&gt;But more importantly, this is a manual on how to think about distributed systems—the mental models, the failure modes, and the elegant solutions that emerge when you build things from first principles.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;part-i-the-foundation&quot;&gt;PART I: The Foundation&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;chapter-1-the-communication-problem&quot;&gt;Chapter 1: The Communication Problem&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;the-challenge-of-distributed-communication&quot;&gt;The Challenge of Distributed Communication&lt;&#x2F;h4&gt;
&lt;p&gt;In a distributed system, processes don&#x27;t share memory. They communicate over the network, which is unreliable, slow, and can fail at any moment. Before we can build a distributed MapReduce, we need a way for the Master to tell Workers what to do, and for Workers to report results back.&lt;&#x2F;p&gt;
&lt;p&gt;This is the RPC problem: how do we make a network call look like a local function call?&lt;&#x2F;p&gt;
&lt;h4 id=&quot;attempt-1-raw-tcp-sockets&quot;&gt;Attempt 1: Raw TCP Sockets&lt;&#x2F;h4&gt;
&lt;p&gt;The first version of this project started with raw TCP sockets. Workers would connect to the Master and exchange serialized messages:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo z-code&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;Worker: &amp;quot;I&amp;#39;d like a task, please&amp;quot;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;Master: &amp;quot;Here&amp;#39;s task #3 - process input&#x2F;file1.txt&amp;quot;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;Worker: &amp;quot;Done! Here are my results: {word1: 42, word2: 17, ...}&amp;quot;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This approach works but has serious limitations:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;No contract&lt;&#x2F;strong&gt;: Every message format must be manually defined and validated&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;No type safety&lt;&#x2F;strong&gt;: You&#x27;re serializing bytes and hoping both sides agree on the format&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;No code generation&lt;&#x2F;strong&gt;: Every new RPC method requires writing boilerplate&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h4 id=&quot;the-solution-grpc-with-protocol-buffers&quot;&gt;The Solution: gRPC with Protocol Buffers&lt;&#x2F;h4&gt;
&lt;p&gt;gRPC solves these problems by using Protocol Buffers (proto3) for schema definition:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo z-code&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;service MapReduce {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  rpc GetTask (Empty) returns (TaskResponse);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  rpc MapDone (MapDoneRequest) returns (Empty);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  rpc ReduceDone (ReduceDoneRequest) returns (Empty);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;message TaskResponse {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  string task_type = 1;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  uint32 task_id = 2;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  repeated string input_files = 3;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  uint32 n_reduce = 4;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;  string output_path = 5;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The key insight is that the &lt;code&gt;.proto&lt;&#x2F;code&gt; file is the &lt;strong&gt;single source of truth&lt;&#x2F;strong&gt;. From this definition, code is automatically generated for both client and server. This guarantees that both sides speak the same protocol—type errors become compile-time errors, not runtime surprises.&lt;&#x2F;p&gt;
&lt;p&gt;Rust&#x27;s implementation of gRPC comes from the &lt;strong&gt;tonic&lt;&#x2F;strong&gt; crate, which provides an async runtime built on top of tokio. This is perfect for our use case: workers can process tasks concurrently while waiting for RPC responses.&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo z-code&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;&#x2F;&#x2F; From src&#x2F;client.rs&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;pub async fn get_task(&amp;amp;mut self) -&amp;gt; Result&amp;lt;TaskType, Box&amp;lt;dyn std::error::Error&amp;gt;&amp;gt; {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    let response = self.inner.get_task(mr::Empty {}).await?.into_inner();&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &#x2F;&#x2F; Type-safe response parsing - the compiler catches mismatches&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    match response.task_type.as_str() {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        &amp;quot;map&amp;quot; =&amp;gt; TaskType::Map { ... },&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        &amp;quot;reduce&amp;quot; =&amp;gt; TaskType::Reduce { ... },&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        &amp;quot;idle&amp;quot; =&amp;gt; TaskType::Idle,&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        &amp;quot;exit&amp;quot; =&amp;gt; TaskType::Exit,&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;chapter-2-the-architecture-that-emerged&quot;&gt;Chapter 2: The Architecture That Emerged&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;the-master-worker-pattern&quot;&gt;The Master-Worker Pattern&lt;&#x2F;h4&gt;
&lt;p&gt;The commit history shows the natural evolution of this project:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Initial commit&lt;&#x2F;strong&gt; - Types and structure definitions&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;TCP implementation&lt;&#x2F;strong&gt; - Raw socket communication&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;gRPC migration&lt;&#x2F;strong&gt; - Using tonic for type-safe RPC&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;This pattern is universal in distributed systems: a central coordinator (Master) assigns work to multiple workers who execute in parallel. The Master doesn&#x27;t do the heavy lifting—it orchestrates.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s how the architecture looks:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo z-code&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;┌─────────────┐         gRPC         ┌─────────────┐&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;│   Master    │ ◄──────────────────► │   Worker 1  │&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;│  (Port 50051)│                     │  (Task: Map)│&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;└─────────────┘                     └─────────────┘&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;      │                                    │&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;      │                                    │&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;      ▼                                    ▼&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;┌─────────────┐                     ┌─────────────┐&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;│ Task Queue  │                     │   Worker 2  │&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;│  - Map 0-4  │                     │ (Task: Map) │&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;│  - Reduce 0-4                     └─────────────┘&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;└─────────────┘&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The Master maintains two task queues: one for Map tasks and one for Reduce tasks. Workers poll the Master for work, execute the task, and report back when complete.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;part-ii-the-master&quot;&gt;PART II: The Master&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;chapter-3-the-task-scheduling-problem&quot;&gt;Chapter 3: The Task Scheduling Problem&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;the-naive-approach&quot;&gt;The Naive Approach&lt;&#x2F;h4&gt;
&lt;p&gt;A first attempt at task scheduling might look like this:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo z-code&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;fn get_task(&amp;amp;mut self) -&amp;gt; Response {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &#x2F;&#x2F; Find any idle task&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    if let Some((id, _)) = self.map_task.iter().find(|(_, s)| **s == Idle) {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        return Response::Task { task_id: id, ... };&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    Response::NoTask&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This works—until it doesn&#x27;t. The problem emerges when:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Worker A claims Task 1&lt;&#x2F;li&gt;
&lt;li&gt;Worker A crashes&lt;&#x2F;li&gt;
&lt;li&gt;Task 1 is now &quot;InProgress&quot; forever&lt;&#x2F;li&gt;
&lt;li&gt;All other workers are idle waiting for Task 1&lt;&#x2F;li&gt;
&lt;li&gt;The entire job is deadlocked&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h4 id=&quot;the-solution-task-status-tracking&quot;&gt;The Solution: Task Status Tracking&lt;&#x2F;h4&gt;
&lt;p&gt;The implementation tracks detailed task state:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo z-code&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;&#x2F;&#x2F; From src&#x2F;rpc.rs&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;pub enum TaskStatus {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    Idle,&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    InProgress {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        start_time: std::time::Instant,&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        backup_scheduled: bool,&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    },&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    Completed,&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The Master knows exactly which tasks are:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Idle&lt;&#x2F;strong&gt;: Available for workers to claim&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;InProgress&lt;&#x2F;strong&gt;: Currently being processed (with timestamp!)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Completed&lt;&#x2F;strong&gt;: Successfully finished&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;chapter-4-the-fault-tolerance-problem&quot;&gt;Chapter 4: The Fault Tolerance Problem&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;the-10-rule&quot;&gt;The 10% Rule&lt;&#x2F;h4&gt;
&lt;p&gt;Google&#x27;s original MapReduce paper introduced a clever solution: when 5% of tasks remain, start scheduling &lt;strong&gt;backup tasks&lt;&#x2F;strong&gt; for in-progress work. If the original worker finishes, its results are ignored. If it fails, the backup task provides the result.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s the implementation:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo z-code&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;&#x2F;&#x2F; From src&#x2F;master.rs&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;fn should_schedule_backup(&amp;amp;self) -&amp;gt; bool {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    let total = self.map_task.len();&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    let completed = self.map_task.values()&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        .filter(|s| matches!(s, TaskStatus::Completed))&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        .count();&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    let remaining = total - completed;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    remaining &amp;lt;= (total as f64 * 0.05) as usize&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When should_backup() returns true, the Master looks for tasks that have been running for more than 10 seconds without a backup scheduled:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo z-code&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;let backup_threshold = Duration::from_secs(10);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;let backup_task = self.map_task.iter()&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    .find(|(_, status)| {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        matches!(status, TaskStatus::InProgress { start_time, backup_scheduled }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            if !backup_scheduled &amp;amp;&amp;amp; start_time.elapsed() &amp;gt; backup_threshold)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    });&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is the &lt;strong&gt;speculative execution&lt;&#x2F;strong&gt; pattern—running the same task twice in parallel, using whichever finishes first.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;chapter-5-the-health-check-problem&quot;&gt;Chapter 5: The Health Check Problem&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;detecting-stuck-tasks&quot;&gt;Detecting Stuck Tasks&lt;&#x2F;h4&gt;
&lt;p&gt;What happens when a worker doesn&#x27;t crash but just... stops responding? The backup mechanism won&#x27;t help because no backup is scheduled until 10 seconds elapse.&lt;&#x2F;p&gt;
&lt;p&gt;The solution is periodic health checks:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo z-code&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;&#x2F;&#x2F; From src&#x2F;master.rs&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;pub fn health_check(&amp;amp;mut self, timeout_secs: u64) {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    let timeout = Duration::from_secs(timeout_secs);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    for (task_id, status) in &amp;amp;mut self.map_task {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        if let TaskStatus::InProgress { start_time, .. } = status {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            if start_time.elapsed() &amp;gt; timeout {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;                log::warn!(&amp;quot;Map task {} timed out, resetting to Idle&amp;quot;, task_id);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;                *status = TaskStatus::Idle;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The Master runs a background thread that checks every 10 seconds whether any tasks have been &quot;InProgress&quot; for more than 30 seconds. If so, it resets them to Idle, making them available for other workers.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;This is the core insight of fault tolerance&lt;&#x2F;strong&gt;: assume things will fail, detect failures aggressively, and recover gracefully.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;chapter-6-phase-transitions&quot;&gt;Chapter 6: Phase Transitions&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;the-map-reduce-handoff&quot;&gt;The Map → Reduce Handoff&lt;&#x2F;h4&gt;
&lt;p&gt;One of the trickiest parts of MapReduce is knowing when to switch phases:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo z-code&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;&#x2F;&#x2F; From src&#x2F;master.rs&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;fn handle_map_done(&amp;amp;mut self, task_id: u32, files: HashMap&amp;lt;u32, String&amp;gt;) {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    self.map_task.insert(task_id, TaskStatus::Completed);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    self.map_outputs.insert(task_id, files);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &#x2F;&#x2F; Check if ALL map tasks are completed&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    let all_done = self.map_task.values()&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        .all(|s| matches!(s, TaskStatus::Completed));&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    if all_done &amp;amp;&amp;amp; self.phase == Phase::Map {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        self.phase = Phase::Reduce;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        &#x2F;&#x2F; Initialize reduce tasks&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        for i in 0..self.n_reduce {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            self.reduce_task.insert(i, TaskStatus::Idle);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The Master won&#x27;t assign Reduce tasks until every Map task is complete. This makes sense: you can&#x27;t reduce until you have all the intermediate data from the Map phase.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;part-iii-the-worker&quot;&gt;PART III: The Worker&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;chapter-7-the-map-phase&quot;&gt;Chapter 7: The Map Phase&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;input-processing&quot;&gt;Input Processing&lt;&#x2F;h4&gt;
&lt;p&gt;When a worker receives a Map task, it reads the input file and transforms it into key-value pairs:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo z-code&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;&#x2F;&#x2F; From src&#x2F;worker.rs&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;fn map(_filename: &amp;amp;String, content: String) -&amp;gt; Vec&amp;lt;KeyValue&amp;gt; {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &#x2F;&#x2F; Split content into words, each with count 1&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    let mut d: Vec&amp;lt;(&amp;amp;str, u32)&amp;gt; = content.split(&amp;quot; &amp;quot;).map(|x| (x, 1)).collect();&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    d.sort_by_key(|f| f.0);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    &#x2F;&#x2F; Group by key and reduce (count occurrences)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    let mut kvs = Vec::new();&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    let mut i = 0;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    while i &amp;lt; d.len() {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        let key = d[i].0;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        let mut values = Vec::new();&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        while i &amp;lt; d.len() &amp;amp;&amp;amp; key == d[i].0 {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            values.push(d[i].1);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            i += 1;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        let result = reduce(key.to_string(), values);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        let kv = result.split_once(&amp;quot; &amp;quot;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            .map(|(k, v)| KeyValue { key: k.to_string(), value: v.to_string() })&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            .expect(&amp;quot;Unable to Convert to key Value form&amp;quot;);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        kvs.push(kv);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    kvs&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For input &quot;hello world hello&quot;, this produces:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;(&quot;hello&quot;, &quot;2&quot;)&lt;&#x2F;li&gt;
&lt;li&gt;(&quot;world&quot;, &quot;1&quot;)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;partitioning-the-hash-function&quot;&gt;Partitioning: The Hash Function&lt;&#x2F;h4&gt;
&lt;p&gt;The worker must now decide which Reduce partition should handle each key. This uses consistent hashing:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo z-code&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;&#x2F;&#x2F; From src&#x2F;worker.rs&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;pub fn ihash(key: &amp;amp;str) -&amp;gt; u32 {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    let mut hasher = DefaultHasher::new();&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    key.hash(&amp;amp;mut hasher);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    hasher.finish() as u32&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;&#x2F;&#x2F; In the Map task execution:&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;let partition_id = ihash(&amp;amp;kv.key) % data.n_reduce;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;All occurrences of &quot;hello&quot; will hash to the same partition, ensuring they&#x27;re processed together in Reduce.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;atomic-file-writing&quot;&gt;Atomic File Writing&lt;&#x2F;h4&gt;
&lt;p&gt;Workers write intermediate files using atomic operations:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo z-code&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;&#x2F;&#x2F; Write to temp file first&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;let temp_filename = format!(&amp;quot;{}&#x2F;mr-{}-{}.tmp&amp;quot;, output_path, task_id, partition_id);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;let final_filename = format!(&amp;quot;{}&#x2F;mr-{}-{}&amp;quot;, output_path, task_id, partition_id);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;let mut file = File::create(&amp;amp;temp_filename)?;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;for v in &amp;amp;values {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    writeln!(file, &amp;quot;{}&amp;quot;, v)?;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;file.flush()?;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;&#x2F;&#x2F; Atomic rename - either fully written or not visible&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;fs::rename(&amp;amp;temp_filename, &amp;amp;final_filename)?;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The key insight: writing to a temporary file and then renaming is atomic on most filesystems. If the worker crashes mid-write, the original file remains intact.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;chapter-8-the-reduce-phase&quot;&gt;Chapter 8: The Reduce Phase&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;collecting-intermediate-files&quot;&gt;Collecting Intermediate Files&lt;&#x2F;h4&gt;
&lt;p&gt;Reduce workers receive a list of intermediate files from the Master:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo z-code&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;&#x2F;&#x2F; From src&#x2F;master.rs - when assigning reduce task&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;let mut input_files = Vec::new();&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;for (_map_id, files) in &amp;amp;self.map_outputs {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    if let Some(file) = files.get(&amp;amp;id) {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        input_files.push(file.clone());&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is the &quot;shuffle&quot; phase—each Reduce task gets ALL intermediate files for its partition.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;sorting-and-aggregation&quot;&gt;Sorting and Aggregation&lt;&#x2F;h4&gt;
&lt;p&gt;The Reduce worker reads all intermediate files, sorts by key, and aggregates:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo z-code&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;&#x2F;&#x2F; From src&#x2F;worker.rs&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;&#x2F;&#x2F; Read all input files into a single vector&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;let mut all_kv: Vec&amp;lt;(String, u32)&amp;gt; = Vec::new();&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;for file in &amp;amp;data.input_files {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    let content = read_to_string(file)?;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    for item in content.split(&amp;quot;;&amp;quot;) {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        if let Some((k, v)) = item.split_once(&amp;quot;,&amp;quot;) {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            if !k.is_empty() {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;                all_kv.push((k.to_string(), v.parse().unwrap_or(0)));&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;            }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;&#x2F;&#x2F; Sort by key&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;all_kv.sort_by_key(|f| f.0.clone());&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;&#x2F;&#x2F; Aggregate: group by key, sum values&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;let mut i = 0;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;while i &amp;lt; all_kv.len() {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    let key = all_kv[i].0.clone();&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    let mut values = Vec::new();&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    while i &amp;lt; all_kv.len() &amp;amp;&amp;amp; key == all_kv[i].0 {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        values.push(all_kv[i].1);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;        i += 1;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    let result = reduce(key, values);&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    writeln!(file, &amp;quot;{}&amp;quot;, result)?;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is the classic &quot;sort-merge&quot; pattern: data is sorted by key, then a single pass groups and aggregates identical keys.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;part-iv-the-complete-system&quot;&gt;PART IV: The Complete System&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;chapter-9-the-code-architecture&quot;&gt;Chapter 9: The Code Architecture&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;module-structure&quot;&gt;Module Structure&lt;&#x2F;h4&gt;
&lt;pre class=&quot;giallo z-code&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;src&#x2F;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;├── lib.rs          # Public API - re-exports all modules&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;├── master.rs       # Master implementation - scheduling, fault tolerance&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;├── worker.rs       # Worker implementation - map&#x2F;reduce logic&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;├── rpc.rs          # RPC types - requests, responses, task status&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;├── models.rs       # Domain models - KeyValue, Report&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;├── server.rs       # gRPC server - tonic service implementation&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;└── client.rs       # gRPC client - worker side RPC calls&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;bin&#x2F;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;├── master.rs       # Master binary entry point&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;└── worker.rs       # Worker binary entry point&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h4 id=&quot;separation-of-concerns&quot;&gt;Separation of Concerns&lt;&#x2F;h4&gt;
&lt;p&gt;The architecture follows clean separation:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;rpc.rs&lt;&#x2F;strong&gt; defines the communication contract&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;master.rs&lt;&#x2F;strong&gt; implements scheduling logic&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;worker.rs&lt;&#x2F;strong&gt; implements data processing&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;server.rs&lt;&#x2F;strong&gt; &#x2F; &lt;strong&gt;client.rs&lt;&#x2F;strong&gt; handle gRPC boilerplate&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;This makes the code testable and maintainable. The Master logic can be tested without network calls; the Worker can run locally without a Master.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;chapter-10-running-the-system&quot;&gt;Chapter 10: Running the System&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;starting-the-master&quot;&gt;Starting the Master&lt;&#x2F;h4&gt;
&lt;pre class=&quot;giallo z-code&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;cargo run --release --bin master 50051&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The Master starts on port 50051 with the default configuration:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Input files: input&#x2F;file1.txt through input&#x2F;file5.txt&lt;&#x2F;li&gt;
&lt;li&gt;Number of reduce tasks: 5&lt;&#x2F;li&gt;
&lt;li&gt;Output directory: output&#x2F;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;starting-workers&quot;&gt;Starting Workers&lt;&#x2F;h4&gt;
&lt;pre class=&quot;giallo z-code&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;cargo run --release --bin worker http:&#x2F;&#x2F;127.0.0.1:50051&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Workers connect to the Master and automatically pick up tasks. Start multiple workers to see parallel execution:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo z-code&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;# Terminal 1&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;cargo run --release --bin master 50051&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;# Terminal 2&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;cargo run --release --bin worker http:&#x2F;&#x2F;127.0.0.1:50051&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;# Terminal 3&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;cargo run --release --bin worker http:&#x2F;&#x2F;127.0.0.1:50051&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The log output shows the system in action:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo z-code&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;# Master logs:&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;INFO mapreduce::server: gRPC Master listening on 127.0.0.1:50051&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;INFO mapreduce::master: All map tasks complete, switching to Reduce phase&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;INFO mapreduce::master: All reduce tasks complete, job finished!&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;# Worker logs:&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;INFO mapreduce::worker: Asking for task...&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;INFO mapreduce::worker: Map task 0 complete, sending MapDone...&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;INFO mapreduce::worker: Asking for task...&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;INFO mapreduce::worker: Reduce task 2 complete, sending ReduceDone...&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;chapter-11-the-final-architecture-diagram&quot;&gt;Chapter 11: The Final Architecture Diagram&lt;&#x2F;h3&gt;
&lt;pre class=&quot;giallo z-code&quot;&gt;&lt;code data-lang=&quot;plain&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;┌─────────────────────────────────────────────────────────────────┐&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;│                         Master                                  │&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;│  ┌─────────────┐  ┌──────────────┐  ┌─────────────────────────┐│&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;│  │ Task Queue  │  │ Health Check │  │ Phase Transitions       ││&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;│  │ - Map 0-4   │  │ Every 10s    │  │ Map → Reduce → Done     ││&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;│  │ - Reduce 0-4│  │              │  │                         ││&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;│  └─────────────┘  └──────────────┘  └─────────────────────────┘│&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;│          │                │                      │              │&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;│          ▼                ▼                      ▼              │&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;│  ┌─────────────────────────────────────────────────────────────┐│&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;│  │                    gRPC Server (tonic)                       ││&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;│  │  - get_task() → TaskResponse                                ││&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;│  │  - map_done(MapDoneRequest) → Empty                        ││&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;│  │  - reduce_done(ReduceDoneRequest) → Empty                   ││&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;│  └─────────────────────────────────────────────────────────────┘│&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;└─────────────────────────────────────────────────────────────────┘&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;         │                    │                    │&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;         ▼                    ▼                    ▼&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;│    Worker 1     │  │    Worker 2     │  │    Worker 3     │&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;│  ┌───────────┐  │  │  ┌───────────┐  │  │  ┌───────────┐  │&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;│  │ Map Phase │  │  │  │ Map Phase │  │  │  │   Idle    │  │&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;│  │ Read file │  │  │  │ Read file │  │  │  └───────────┘  │&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;│  │ Partition │  │  │  │ Partition │  │  │                  │&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;│  └───────────┘  │  │  └───────────┘  │  │                  │&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;└─────────────────┘  └─────────────────┘  └─────────────────┘&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;         │                    │                    │&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;         ▼                    ▼                    ▼&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    output&#x2F;mr-0-*       output&#x2F;mr-1-*          (waiting)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;epilogue-the-rust-advantage&quot;&gt;Epilogue: The Rust Advantage&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;why-rust-for-distributed-systems&quot;&gt;Why Rust for Distributed Systems?&lt;&#x2F;h3&gt;
&lt;p&gt;Building this in Rust provided several advantages:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Memory Safety&lt;&#x2F;strong&gt;: No segfaults or data races, even with concurrent workers&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Async&#x2F;Await&lt;&#x2F;strong&gt;: Tonic&#x27;s async gRPC fits naturally with tokio&#x27;s cooperative multitasking&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Type Safety&lt;&#x2F;strong&gt;: The compiler catches mistakes that would slip through in other languages&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;what-this-journey-taught-me&quot;&gt;What This Journey Taught Me&lt;&#x2F;h3&gt;
&lt;p&gt;The MapReduce paper is 20 years old, but the lessons remain:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Abstraction simplifies complexity&lt;&#x2F;strong&gt;: The Map&#x2F;Reduce split hides enormous complexity behind simple function signatures&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Fault tolerance is an afterthought in design, a first-thought in implementation&lt;&#x2F;strong&gt;: Every line of code assumes things will fail&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Small, focused components&lt;&#x2F;strong&gt;: The Master doesn&#x27;t process data; it only coordinates. Workers don&#x27;t coordinate; they only process. This separation makes each piece understandable&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;The power of streaming&lt;&#x2F;strong&gt;: Both Map and Reduce are streaming transformations—they don&#x27;t need to hold all data in memory&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;the-code&quot;&gt;The Code&lt;&#x2F;h3&gt;
&lt;p&gt;This implementation is available on GitHub:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Repository&lt;&#x2F;strong&gt;: &lt;a rel=&quot;external&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ygndotgg&#x2F;map_reduce-&quot;&gt;https:&#x2F;&#x2F;github.com&#x2F;ygndotgg&#x2F;map_reduce-&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The commit history tells the story of evolution:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;TCP sockets → gRPC migration&lt;&#x2F;li&gt;
&lt;li&gt;Sequential → Concurrent workers&lt;&#x2F;li&gt;
&lt;li&gt;Basic task scheduling → Backup task speculation&lt;&#x2F;li&gt;
&lt;li&gt;Health checks for fault tolerance&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;&#x2F;h3&gt;
&lt;p&gt;Building a distributed system from scratch is humbling. Every &quot;simple&quot; operation—reading a file, sending a message, updating state—becomes a source of potential failure. But that&#x27;s exactly why it&#x27;s worth doing.&lt;&#x2F;p&gt;
&lt;p&gt;You don&#x27;t build distributed systems because they&#x27;re easy. You build them because they force you to think clearly about failure, concurrency, and coordination. And you won&#x27;t truly understand those concepts until you&#x27;ve implemented them yourself.&lt;&#x2F;p&gt;
&lt;p&gt;So go ahead—fork the repo, break things, add features. The best way to learn is by doing.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;em&gt;MapReduce in Rust: A Hands-On Guide to Building Distributed Systems from Scratch | my thoughts&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
</description>
      </item>
    </channel>
</rss>
